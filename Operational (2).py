#Name: Operational#Date: 19/5/18#Version: 3#Description: A simple math game#Author: Luke Hawinkels#This definition holds the instructions and displays them on the screen when demandeddef HTP (event=None):    global intInGame, canvas, tkinter, strName    intInGame = 0    #Rebinding the keys so that the user cannot press anything accidently    root.bind('h', GenerateHome)    root.bind('H', GenerateHome)    root.bind('1', GenerateHome)    root.bind('2', GenerateHome)    #Deletes an updates the canvas    canvas.delete("all")    canvas.create_text(300,40, fill="black",font="Times 20 bold", text= strName.title())    canvas.create_text(300,100, fill="black",font="Times 40 bold", text="Operational")    canvas.create_text(300,150, fill="black",font="Times 20 underline bold", text="How To play")    canvas.update()    #Adds instructions    canvas.create_text(300,325, fill="black",font="Times 10", text="The Orange square: \n"                       "you need to land in this square with the correct total to win. \n"                       "The score you need I the score displayed in the square. \n"                       "If the square is blank, it's not a bug it just means \n"                       "that the winning total is 1. \n\n"                       "How To Move: Click on any square adjacent to either the green \n"                       "square or the square you last clicked. To backtrack click on \n"                       "the square with the darkest shade of blue. Each move forward \n"                       "will add one to your total unless that square has an \n"                       "operation on it or it is the orange square. \n\n"                       "Navigational features: \n"                       "To move between menus you can use the buttons or use the \n"                       "character printed in each button as a keyboard entry. To \n"                       "turn the music on or off use the button or the 'm' key on \n"                       "your keyboard. To change game mode in game press the number \n"                       "which corresponds to the other game mode.\n\n"                       "To change from 3 * 3 to 4 * 4 press 2 \n"                       "To change from 4 * 4 to 3 * 3 press 1 ")                                          #Return To Home Button    GenerateReturnToHome(100, 517)    #Music Button    GenerateMusic(275, 575)    #Copyright logo    CopyRight()#Flow Computing Copyrightdef CopyRight():    canvas.create_text(75, 595, fill="black",font="Times 8", text="Â©2018, Flow Computing ltd")#Resets the variables each time the user exits the game. This is done so that every time the user exits a game they have to start again from level 1def ResetParameters():    #Importing all the globals    global popup, listUsedCoordinates, listUsed, tkinter, intTotal, canvas, intClicked, listTotal, intGradient, listUsedCoordinates, listUsed, xLeft, xRight, yUp, yDown    #Resetting all the globals    intGradient = 0    listTotal = []    intClikcked = 0    intTotal = 0    listUsed = []    listUsedCoordinates = []    xLeft = 0    xRight = 0    yUp = 0    yDown = 0#This generates the music buttondef GenerateMusic(x, y):    #Imports the needed globals and sets the music control variables    global label_image, intMusic, listMusicCoordinates    listMusicCoordinates = []    listMusicCoordinates.append([x, y])    #Checks to see if the OS is MAC OS    if intMusic == 1:        #Skipping for Mac users        pass    #If windows OS the program displays the music button    else:        #Puts the image in a button          Music = Button(font="Times 20 bold", command = PlayMusic, anchor = CENTER, bg = "white")            Music.configure(image = label_image, width = 10, activebackground = "#33B5E5", relief = FLAT)        Music.pack()        Music_window = canvas.create_window(x, y, width = 50, anchor=W, window=Music)   #Plays the music and style the music button appropriatelydef PlayMusic(event=None):    #Importing the needed globals    global intPlayed, label_image, listMusicCoordinates    #Checks to see if the button to play has been clicked. It plays the music and updates the music button    if intPlayed == 0:        label_image = PhotoImage(file="MegaPhone Red.gif")         intPlayed = 1        winsound.PlaySound('Python Music (M83).wav', winsound.SND_LOOP + winsound.SND_ASYNC)        GenerateMusic(listMusicCoordinates[-1][0], listMusicCoordinates[-1][1])    #Checks to see if the pause button has been clicked. It stops the muic and update the music button    else:        label_image = PhotoImage(file="MegaPhone White.gif")         intPlayed = 0        winsound.PlaySound(None, winsound.SND_PURGE)        GenerateMusic(listMusicCoordinates[-1][0], listMusicCoordinates[-1][1])#This allows the user to switch game modes while  in game.def ExitCurrentGame(intSubGameMode, intPressed):    global intGameMode, intInGame, intLevel, intLeave    #Checks if the user is actually playing    if intLeave == 0:        if intInGame == 1:            if intGameMode == 1 and intPressed == 1 or intGameMode == 2 and intPressed == 2:                pass            #Creates a popup which asks the user if they really want to leave the game. Specific to the game type which the user is playing            else:                intLevel = 0                popup = Tk()                popup.wm_title("System")                label = ttk.Label(popup, text = "Are you sure you want to quit the current game?", font="Times 12")                label.pack(side="top", fill="x", pady=10)                #If playing 3 X 3                if intGameMode == 1:                    B1 = ttk.Button(popup, text="Stay", command = popup.destroy)                    B2 = ttk.Button(popup, text="Leave", command = lambda:[FourByFour(),popup.destroy()])                #IF playing 4 X 4                else:                    B1 = ttk.Button(popup, text="Stay", command = popup.destroy)                    B2 = ttk.Button(popup, text="Leave", command = lambda:[ThreeByThree(),popup.destroy()])                B1.pack()                B2.pack()                intLeave = 1        #Checks the users sub game mode.        else:            if intSubGameMode == 1:                intPressed = 1                ThreeByThree()            else:                intPressed = 2                FourByFour()            intLevel = 1    else:        pass#Used to determine the action in ExitCurrentGame based on the key the user pressed.def Press1(event=None):    intSubGameMode = 1    intPressed = 1    ExitCurrentGame(intSubGameMode, intPressed)#Used to determine the action in ExitCurrentGame based on the key the user pressed.def Press2(event=None):    intSubGameMode = 2    intPressed = 2    ExitCurrentGame(intSubGameMode, intPressed)#This is the screen which displays the 3 X 3 and 4 X 4 options.def Play (event=None):    #Importing globals    global intInGame, tkinter, canvas, strName    intInGame = 0    #Resetting keys    root.bind('1', ThreeByThree)    root.bind('2', FourByFour)    root.bind('h', GenerateHome)    root.bind('H', GenerateHome)    #Deletes an updates the canvas    canvas.delete("all")    canvas.create_text(300,40, fill="black",font="Times 20 bold", text= strName.title())    canvas.create_text(300,100, fill="black",font="Times 40 bold", text="Operational")    canvas.create_text(300,150, fill="black",font="Times 20 underline bold", text="Play")    canvas.update()        #How to play button    B1 = Button(root, font="Times 20 bold", text = "1:  3 * 3", command = ThreeByThree, anchor = CENTER)    B1.configure(width = 10, activebackground = "#33B5E5", relief = FLAT)    B1_window = canvas.create_window(100, 200, width = 400, anchor=W, window=B1)    #Play button    B2 = Button(root, font="Times 20 bold", text = "2:  4 * 4", command = FourByFour, anchor = CENTER)    B2.configure(width = 10, activebackground = "#33B5E5", relief = FLAT)    B2_window = canvas.create_window(100, 300, width = 400, anchor=W, window=B2)    intLevel == 0    #Music Button    GenerateMusic(275, 500)    #Return to home    GenerateReturnToHome(100, 400)    #Copyright logo    CopyRight()#This is what changes teh colours in the progres bardef GenerateProgressBar():    #Import globals    global intLevel    #This updates the progres bar based on the user level. I did try to make this more efficent but I couldn't find a way to do so.    if intLevel == 0:        canvas.create_rectangle(525, 200, 575, 300, fill="orange", outline="black" )        canvas.create_rectangle(525, 300, 575, 400, fill="red", outline="black" )        canvas.create_rectangle(525, 400, 575, 500, fill="red", outline="black" )        canvas.create_text(550,250, fill="black",font="Times 20 bold", text="1")        canvas.create_text(550,350, fill="black",font="Times 20 bold", text="2")        canvas.create_text(550,450, fill="black",font="Times 20 bold", text="3")    elif intLevel == 1:        canvas.create_rectangle(525, 200, 575, 300, fill="green", outline="black" )        canvas.create_rectangle(525, 300, 575, 400, fill="orange", outline="black" )        canvas.create_rectangle(525, 400, 575, 500, fill="red", outline="black" )        canvas.create_text(550,250, fill="black",font="Times 20 bold", text="1")        canvas.create_text(550,350, fill="black",font="Times 20 bold", text="2")        canvas.create_text(550,450, fill="black",font="Times 20 bold", text="3")           else:        canvas.create_rectangle(525, 200, 575, 300, fill="green", outline="black" )        canvas.create_rectangle(525, 300, 575, 400, fill="green", outline="black" )        canvas.create_rectangle(525, 400, 575, 500, fill="orange", outline="black" )        canvas.create_text(550,250, fill="black",font="Times 20 bold", text="1")        canvas.create_text(550,350, fill="black",font="Times 20 bold", text="2")        canvas.create_text(550,450, fill="black",font="Times 20 bold", text="3")        #GFills the numbers in the gridsdef GenerateGrid(event=None):    #Imports globals    global listUsedlistUsedCoordinates    #Updating the progress bar each time the uer clicks    GenerateProgressBar()    #Checking the user game mode    if intGameMode == 1:        #Setting up the variables needed for repopulating the canvas        intTop = 250        intNumberCount = 0        intLeft = 165        #Populates the grid and checks to see if there are any Null Values        for i in range(3):            if Grid1.list[intNumberCount] == None:                #No element                pass            else:                #Does no print value of 0                if Grid1.list[intNumberCount] == 1:                    pass                else:                    canvas.create_text(intLeft, intTop, fill="black", font="Tines 15 bold", text = Grid1.list[intNumberCount])            intLeft += 130            intNumberCount += 1        intTop += 100        intLeft = 165        for i in range(3):            if Grid1.list[intNumberCount] == None:                #No element                pass            else:                #Does no print value of 0                if Grid1.list[intNumberCount] == 1:                    pass                else:                    canvas.create_text(intLeft, intTop, fill="black", font="Tines 15 bold", text = Grid1.list[intNumberCount])            intLeft += 130            intNumberCount += 1        intTop += 100        intLeft = 165        for i in range(3):            if Grid1.list[intNumberCount] == None:                #No element                pass            else:                #Does no print value of 0                if Grid1.list[intNumberCount] == 1:                    pass                else:                    canvas.create_text(intLeft, intTop, fill="black", font="Tines 15 bold", text = Grid1.list[intNumberCount])            intLeft += 130            intNumberCount += 1    #Generates the 4 X 4 grid                           elif intGameMode ==2:        #Setting up the variables needed for repopulating the canvas        intTop = 237.5        intNumberCount = 0        intLeft = 150        #Populates the grid and checks to see if there are any Null Values        for i in range(4):            if Grid4.list[intNumberCount] == None:                #No element                pass            else:                #Does no print value of 0                if Grid4.list[intNumberCount] == 1:                    pass                else:                    canvas.create_text(intLeft, intTop, fill="black", font="Tines 15 bold", text = Grid4.list[intNumberCount])            intLeft += 100            intNumberCount += 1        intTop += 75        intLeft = 150        for i in range(4):            if Grid4.list[intNumberCount] == None:                #No element                pass            else:                #Does no print value of 0                if Grid4.list[intNumberCount] == 1:                    pass                else:                    canvas.create_text(intLeft, intTop, fill="black", font="Tines 15 bold", text = Grid4.list[intNumberCount])            intLeft += 100            intNumberCount += 1        intTop += 75        intLeft = 150        for i in range(4):            if Grid4.list[intNumberCount] == None:                #No element                pass            else:                #Does no print value of 0                if Grid4.list[intNumberCount] == 1:                    pass                else:                    canvas.create_text(intLeft, intTop, fill="black", font="Tines 15 bold", text = Grid4.list[intNumberCount])            intLeft += 100            intNumberCount += 1        intTop += 75        intLeft = 150        for i in range(4):            if Grid4.list[intNumberCount] == None:                #No element                pass            else:                #Does no print value of 0                if Grid4.list[intNumberCount] == 1:                    pass                else:                    canvas.create_text(intLeft, intTop, fill="black", font="Tines 15 bold", text = Grid4.list[intNumberCount])            intLeft += 100            intNumberCount += 1    #Music Button    GenerateMusic(525, 550)    #Generates return to home buttondef GenerateReturnToHome(x, y):    global intName    #Return to home    RTH = Button(font="Times 20 bold", text = "H:  Return To Home", command = GenerateHome, anchor = CENTER)    RTH.configure(width = 10, activebackground = "#33B5E5", relief = FLAT)    RTH_window = canvas.create_window(x, y, width = 400, anchor=W, window=RTH)    #Reset here for efficency    intName = 1#Add quit functionality to the programdef Quit(event=None):    #Asking the user if they really want to quit the game    popup = Tk()    popup.wm_title("System")    label = ttk.Label(popup, text = "Are you sure you want to quit?", font="Times 12")    label.pack(side="top", fill="x", pady=10)    B1 = ttk.Button(popup, text="Stay", command = popup.destroy)    B2 = ttk.Button(popup, text="quit", command = quit)    B1.pack()    B2.pack()def CreateHomeButtons():    global intMusic    #How to play button    B1 = Button(root, font="Times 20 bold", text = "1:  How To Play", command = HTP, anchor = CENTER)    B1.configure(width = 10, activebackground = "#33B5E5", relief = FLAT)    B1_window = canvas.create_window(100, 200, width = 400, anchor=W, window=B1)    #Play button    B2 = Button(root, font="Times 20 bold", text = "2:  Play", command = Play, anchor = CENTER)    B2.configure(width = 10, activebackground = "#33B5E5", relief = FLAT)    B2_window = canvas.create_window(100, 300, width = 400, anchor=W, window=B2)    #Quit button    B3 = Button(root, font="Times 20 bold", text = "3:  Quit", command = Quit, anchor = CENTER)    B3.configure(width = 10, activebackground = "#33B5E5", relief = FLAT)    B3_window = canvas.create_window(100, 400, width = 400, anchor=W, window=B3)    #Binding keys to correct functions    root.bind('1', HTP)    root.bind('2', Play)    root.bind("3", Quit)    if intMusic == 1:        pass    else:        root.bind('m', PlayMusic)        root.bind("M", PlayMusic)def DeleteMessage():    global intRecreate3    canvas.delete(Message)    intRecreate3 = 0def DeleteMessage1():    global intRecreate, intRecreate1, intRecreate2    canvas.delete(Message1)    intRecreate = 0    intRecreate2 = 0    intRecreate3 = 0def limitSize(*args):    global Message1, EntryBox, mEntry, intRecreate, intNameEntered    if intNameEntered != 1:        value = ment.get()        if len(value) > 17:            ment.set(value[:17])            if intRecreate == 0:                Message1 = canvas.create_text(300,250, fill="red", text="Name must be 17 characters or less")                intRecreate = 1                canvas.after(4000, DeleteMessage1)            else:                pass    else:        pass    #Checks namedef NameCheck():    global mtext, Message, Message1, intName, strName, intRecreate1, intRecreate2, intRecreate3, intNameEntered    mtext = ment.get()    strName = mtext    strName.title()    if len(mtext) >= 2 and mtext.replace(" ", "").isalpha() == True and len(mtext) <= 17:        canvas.delete("all")        canvas.create_text(300,100, fill="black",font="Times 40 bold", text="Operational")        mtext = mtext.title()        intNameEntered = 1        canvas.create_text(300,50, fill="black",font="Times 20 bold", text= mtext)        CreateHomeButtons()        #Music Button        GenerateMusic(275, 500)    else:        if intRecreate3 == 0:            Message = canvas.create_text(300,200, fill="red", text="Invalid")            intRecreate3 = 1            canvas.after(1000, DeleteMessage)        else:            pass        if len(mtext) <= 2:            if intRecreate1 == 0:                Message1 = canvas.create_text(300,250, fill="red", text="Name must be 2 or more characters")                intRecreate1 = 1                canvas.after(4000, DeleteMessage1)            else:                pass        elif mtext.isalpha() == False:            if intRecreate2 == 0:                Message1 = canvas.create_text(300,250, fill="red", text="All characters must be alphnumeric")                intRecreate2 = 1                canvas.after(4000, DeleteMessage1)            else:                pass            intName = 0            return    #Generates the home screendef GenerateHome(event=None):    #Defining, Reseting and importing all necessary variables    global intInGame, Message1, strName, intName, mEntry, mtext, EntryBox, EntryButton, ment, intLevel, popup, listUsedCoordinates, strName, listUsed, tkinter, intTotal, canvas, intClicked, listTotal, intPlayed, intGradient, listUsedCoordinates, listUsed, xLeft, xRight, yUp, yDown    intLevel = 0    intInGame = 0    #Resets all variables    ResetParameters()    #Deletes an updates the canvas    canvas.delete("all")    if intName ==  0:        Message = canvas.create_text(300,300, fill="red", text="In order to procede you must enter your name!")        ment = StringVar()        mEntry = Entry(canvas, textvariable=ment)        EntryBox = canvas.create_window(300, 150, window = mEntry, width = 200)        ment.trace('w', limitSize)        mbutton = Button(canvas, text = "ok", command = NameCheck)        EntryButton = canvas.create_window(300, 180, window = mbutton)    else:        canvas.create_text(300,40, fill="black",font="Times 20 bold", text= strName.title())        CreateHomeButtons()        canvas.create_text(300,100, fill="black",font="Times 40 bold", text="Operational")    canvas.update()    #Music Button    GenerateMusic(275, 500)    #Copyright    CopyRight()#This changes the hade of each square the user clicks on so that their path can be showndef ColourGradient():    #Importing needed globals    global strColourGradient, intGradient, listUsed    intGradient = len(listUsed)    if listUsed[-1] == Grid1.WinningSquare or listUsed[-1] == Grid4.WinningSquare:        intGradient += -1    else:        pass    #List holding all of the colour gradients in hexadecimal format    listGradients = ["#00E9FF", "#00CDFF", "#00B8FF", "#00A4FF", "#008FFF", "#007AFF", "#0067FF", "#004FFF", "#0036FF", "#0023FF", "#000FFF", "#0000FF", "#0000E8", "#0000D2", "#0000BE", "#0000AA"]    strColourGradient = listGradients[intGradient]#This creates the 3 X 3 griddef ThreeByThree(event=None):    #Importing all needed globals    global intInGame, listUsed, tkinter, canvas, intPlayed, intGameMode, OrangeLeft, OrangeRight, OrangeTop, OrangeBottom, intLevel, strName, intLeave    intInGame = 1    ResetParameters()    listUsed = [7]    intPlayed = 0    OrangeLeft = 0    OrangeRight = 0    OrangeTop = 0    OrangeBottom = 0    intGameMode = 1    intLeave = 0    GenerateBoard()    #Deletes an updates the canvas    canvas.delete("all")    canvas.create_text(300,40, fill="black",font="Times 20 bold", text= strName.title())    canvas.create_text(300,100, fill="black",font="Times 40 bold", text="Operational")    canvas.create_text(300,150, fill="black",font="Times 20 underline bold", text="Play")    canvas.update()    #Creating the Grid    intLeft = 100    intRight = 230    intTop = 200    intBottom = 300    intNumberCount = 1    #This is the part that creates the grid    for i in range(3):        for i in range(3):            #Colouring the winning square orange            if intNumberCount == Grid1.WinningSquare:                OrangeLeft = intLeft                OrangeRight = intRight                OrangeTop = intTop                OrangeBottom = intBottom                canvas.create_rectangle(OrangeLeft, OrangeTop, OrangeRight, OrangeBottom, fill="orange", outline="black" )            #If the square is not the winning square it is white            else:                canvas.create_rectangle(intLeft, intTop, intRight, intBottom, fill="white", outline="black" )            intLeft += 130            intRight += 130            intNumberCount += 1        intLeft = 100        intRight = 230        intBottom += 100        intTop += 100    #Creates the starting rectangle    canvas.create_rectangle(100, 500, 230, 400, fill="green", outline="black")    canvas.pack()    #Return to home    GenerateReturnToHome(100, 550)    #Populates The Grid    GenerateGrid()    #Gets posistion of canvas click    canvas.bind("<Button-1>", callback)    canvas.pack()    #Creates the music button    GenerateMusic(525, 550)    #Creates the copyright button    CopyRight()#This creates the 4 X 4 griddef FourByFour(event=None):    #Importing globals    global intInGame, tkinter, canvas, listUsed, intGameMode, intLevel, OrangeLeft, OrangeRight, OrangeTop, OrangeBottom, intPlayed, strName, intLeave    intInGame = 1    ResetParameters()    intGameMode = 2    listUsed = [13]    intPlayed = 0    OrangeLeft = 0    OrangeRight = 0    OrangeTop = 0    OrangeBottom = 0    intLeave = 0    GenerateBoard()    #Deletes an updates the canvas    canvas.delete("all")    canvas.create_text(300,25, fill="black",font="Times 20 bold", text= strName.title())    canvas.create_text(300,50, fill="black",font="Times 40 bold", text="Operational")    canvas.create_text(300,100, fill="black",font="Times 20 underline bold", text="Play")    canvas.update()    #Setting up the variables needed for creating the canvas    intLeft = 100    intRight = 200    intTop = 200    intBottom = 275    intNumberCount = 1    #loop that creates the canvas    for i in range(4):        for i in range(4):            #Colouring the winning square orange            if intNumberCount == Grid4.WinningSquare:                OrangeLeft = intLeft                OrangeRight = intRight                OrangeTop = intTop                OrangeBottom = intBottom                canvas.create_rectangle(OrangeLeft, OrangeTop, OrangeRight, OrangeBottom, fill="orange", outline="black" )            #If the square is not the winning square it is coloured white            else:                canvas.create_rectangle(intLeft, intTop, intRight, intBottom, fill="white", outline="black" )            intNumberCount += 1            intLeft += 100            intRight += 100        intLeft = 100        intRight = 200        intBottom += 75        intTop += 75    #Colours the starting square green    canvas.create_rectangle(100, 425, 200, 500, fill="green", outline="black")    canvas.pack()    #Generates the grid    GenerateGrid()    #Return to home    GenerateReturnToHome(100, 550)    #Gets posistion of canvas click    canvas.bind("<Button-1>", callback)    canvas.pack()    #Generates the music button    GenerateMusic(525, 550)    #Generate the copyright button    CopyRight()#controls the user leveldef LevelUp():    global popup, intPlayed, intTotal, intLevel    #Reset the total between level    intTotal == 0    intLevel += 1    #If the user has not passed teh last level the program says level up    if intLevel != 3:        popup = Tk()        popup.wm_title("System")        label = ttk.Label(popup, text = "Level Up! Well Done.", font="Times 20")        label.pack(side="top", fill="x", pady=10)        B1 = ttk.Button(popup, text="Okay", command = popup.destroy)        B1.pack()        popup.after(2000, PopupDestroy)    #If the user has pased all levels they return to home    else:        popup = Tk()        popup.wm_title("System")        label = ttk.Label(popup, text = "Game Complete! Well Done.", font="Times 20")        label.pack(side="top", fill="x", pady=10)        B1 = ttk.Button(popup, text="Return To Home", command = lambda:[GenerateHome(),popup.destroy()])        B1.pack()        #Disables game board        #Destroys teh popupdef PopupDestroy():    popup.destroy()    #Generates Blue Tilesdef GenerateTile(xLeft, yUp, xRight, yDown, intClicked):    global listUsed, listUsedCoordinates, OrangeLeft, OrangeRight, OrangeTop, OrangeBottom, intGameMode, strColourGradient, intGradient    ColourGradient()    #Checks to see if user has already clicked that tile    if len(listUsed) != 0 and listUsed[-1] == intClicked:        xLeft = listUsedCoordinates[-1][0]        yUp = listUsedCoordinates[-1][1]        xRight = listUsedCoordinates[-1][2]        yDown = listUsedCoordinates[-1][3]        #Checks the user game mode        if intGameMode == 1:            #If the winning square it is refilled orange            if intClicked == Grid1.WinningSquare:                canvas.create_rectangle(OrangeLeft, OrangeTop, OrangeRight, OrangeBottom, fill="orange", outline="black" )            #If not winning square it is refilled white            else:                canvas.create_rectangle(xRight, yUp, xLeft, yDown, fill="white", outline="black")        #Checks the user game mode        else:            #If winning square it is refilled orange            if intClicked == Grid4.WinningSquare:                canvas.create_rectangle(OrangeLeft, OrangeTop, OrangeRight, OrangeBottom, fill="orange", outline="black" )            #Else refilled white            else:                canvas.create_rectangle(xRight, yUp, xLeft, yDown, fill="white", outline="black")            #Squares removed from list        listUsedCoordinates.pop()        listUsed.pop()    #If tile is unclicked the game adds to appropriate lists    else:        #fills the clicked part of the canvas.        canvas.create_rectangle(xRight, yUp, xLeft, yDown, fill=strColourGradient, outline="black")        if intGameMode == 1:            canvas.create_text(xLeft + 30, yUp + 50, fill="black",font="Times 20 bold", text=intTotal)        else:            canvas.create_text(xLeft + 20, yUp + 38, fill="black",font="Times 20 bold", text=intTotal)        #Adding to the lists        listUsed.append(intClicked)        listUsedCoordinates.append([xLeft, yUp, xRight, yDown])#Repopulates the canvasdef GenerateBoard():    global intGameMdode    intRandom = 0    intPath = 0    listRandom = []    listPopulatedPath3X3 = ['', '', '', '', '', '', 0, '', '']    listPopulatedPath4X4 = ['', '', '', '', '', '', '', '', '', '', '', '', 0, '', '', '']    total_score = 0    intWinningSquare = 0    intTotal = 0    #The possible paths    list3X3Paths = [[4, 1, 2, 3, 6, 5, 8, 9], [8, 9, 6, 5, 4, 1, 2, 3], [8, 5, 4, 1, 2, 3, 6, 9], [4, 5, 8, 9, 6, 3, 2, 1], [8, 9, 6, 3, 2, 5, 4 ,1]]    list4X4Paths = [[9, 5, 1, 2, 6, 10 , 14, 15, 11, 7, 3, 4, 8, 12, 16], [9, 5, 1, 2, 6, 10, 14, 15, 16, 12, 11, 7, 8, 4, 3], [14, 15, 16, 12, 11, 10, 9, 5, 6, 7, 8, 4, 3, 2, 1], [14, 10, 9, 5, 1, 2, 6, 7, 3, 4, 8, 12, 16]]    listPath = []    try:        #This code generates random numbers, generates a random path and works out the sum and winning square of the board        if intGameMode == 1:            for i in range(random.randint(3, 7)):                listRandom.append(random.randint(-9, 9))            intPath = random.randint(0, 4)            intCount = 0            for i in range(len(listRandom)):                listPopulatedPath3X3[list3X3Paths[intPath][intCount] - 1] = listRandom[-1]                intCount += 1                listRandom.pop()            intWinningSquare = list3X3Paths[intPath][intCount]            intCount = 0            for i in range(len(listPopulatedPath3X3)):                if listPopulatedPath3X3[intCount] == '':                    pass                else:                    intTotal += listPopulatedPath3X3[intCount]                intCount += 1            intTotal += 1            if intTotal == 1:                GenerateBoard()            else:                pass            listPopulatedPath3X3[intWinningSquare - 1] = intTotal            intCount = 0            for i in range(len(listPopulatedPath3X3)):                if listPopulatedPath3X3[intCount] == '':                    listPopulatedPath3X3[intCount] = random.randint(1, 9)                else:                    pass                intCount += 1            Grid1.SetValues(listPopulatedPath3X3, intTotal, intWinningSquare)                        else:            listRandom = []            #Choosing a path            for i in range(random.randint(3, 14)):                listRandom.append(random.randint(-9, 9))            intPath = random.randint(0, 4)            intCount = 0            for i in range(len(listRandom)):                listPopulatedPath4X4[list4X4Paths[intPath][intCount] - 1] = listRandom[-1]                intCount += 1                listRandom.pop()            intWinningSquare = list4X4Paths[intPath][intCount]            intCount = 0            for i in range(len(listPopulatedPath4X4)):                if listPopulatedPath4X4[intCount] == '':                    pass                else:                    intTotal += listPopulatedPath4X4[intCount]                intCount += 1            intTotal += 1            if intTotal == 1:                GenerateBoard()            else:                pass            listPopulatedPath4X4[intWinningSquare - 1] = intTotal            intCount = 0            for i in range(len(listPopulatedPath4X4)):                if listPopulatedPath4X4[intCount] == '':                    listPopulatedPath4X4[intCount] = random.randint(1, 9)                else:                    pass                intCount += 1            Grid4.SetValues(listPopulatedPath4X4, intTotal, intWinningSquare)    except:        GenerateBoard()#This controls the events that happen when the user clicksdef callback(event):    global listUsed, intTotal, intClicked, intLevel    #Setting up the variables needed for repopulating the canvas    intLeft = 165    intTop = 250    intNumberCount = 0    intClicked = 0    try:        #This part is for the 3 X 3 grid        if intGameMode == 1:            #Controls which part of the grid is being used based on it's vertical posistion. This does not need to be reset within the for loop.            yUp = 200            yDown = 300            for i in range(3):                #controls the horizontal part of the grid being used. It is reset for each row on the gridbeing                xLeft = 100                xRight = 230                #where has the user clicked                for i in range(3):                    intClicked += 1                    if event.x >= xLeft and event.x <=xRight and event.y >=yUp and event.y <=yDown:                        #Error checking to make sure that the user cannot click the wrong square. Each square is indexed so I can check whatsqure the user cloicked and compare to the squares that they are allowed to click.                        if intClicked in listUsed and intClicked != listUsed[-1]:                            break                        if intClicked == listUsed[-1] - 1 or intClicked == listUsed[-1] + 1 or intClicked == listUsed[-1] - 3 or intClicked == listUsed[-1] + 3 or intClicked == listUsed[-1] + 0:                            if intClicked == 6 and listUsed[-1] == 7 or intClicked == 3 and listUsed[-1] == 4 or intClicked == 4 and listUsed[-1] == 3 or intClicked == 7 and listUsed[-1] == 6 or intClicked == 7:                                break                            else:                                #Checks to see if user has won                                if intTotal == Grid1.WinningTotal - 1 and intClicked == Grid1.WinningSquare:                                    #Auto next level                                    intTotal = 0                                    if intLevel != 3:                                        LevelUp()                                    else:                                        LevelUp()                                        break                                    #CHANGE THESE TO THE ACTUAL VALUES THAT I WILL USE                                    if intLevel == 1:                                        GenerateBoard()                                        ThreeByThree()                                        break                                    else:                                        GenerateBoard()                                        ThreeByThree()                                        break                                #Working out the users score                                if intClicked == listUsed[-1]:                                    intTotal -= Grid1.list[intClicked - 1]                                else:                                    intTotal += Grid1.list[intClicked - 1]                                GenerateTile(xLeft, yUp, xRight, yDown, intClicked)                                #Adding the total                                GenerateGrid()                                #Breaks the loop after the definition is triggered                                break                        else:                            break                    else:                        xLeft += 130                        xRight += 130                yUp += 100                yDown += 100        #This part if for the 4 X 4 Grid        else:            yUp = 200            yDown = 275            for i in range(4):                #controls the horizontal part of the grid being used. It is reset for each row on the gridbeing                xLeft = 100                xRight = 200                #where has the user clicked                for i in range(4):                    intClicked += 1                    if event.x >= xLeft and event.x <=xRight and event.y >=yUp and event.y <=yDown:                        #Error checking to make sure that the user cannot click the wrong square. Each square is indexed so I can check whatsqure the user cloicked and compare to the squares that they are allowed to click.                        if intClicked in listUsed and intClicked != listUsed[-1]:                            break                        if intClicked == listUsed[-1] - 1 or intClicked == listUsed[-1] + 1 or intClicked == listUsed[-1] - 4 or intClicked == listUsed[-1] + 4 or intClicked == listUsed[-1] + 0:                            if intClicked == listUsed[-1] and len(listUsed) == 16:                                if intClicked == Grid4.WinningSquare:                                    canvas.create_rectangle(xRight, yUp, xLeft, yDown, fill="orange", outline="black")                                else:                                    canvas.create_rectangle(xRight, yUp, xLeft, yDown, fill="white", outline="black")                                listUsed.pop()                                listUsedCoordinates.pop()                                GenerateGrid()                                GenerateTile()                            else:                                pass                            if intClicked == 12 and listUsed[-1] == 13 or intClicked == 8 and listUsed[-1] == 9 or intClicked == 4 and listUsed[-1] == 5 or intClicked == 5 and listUsed[-1] == 4 or intClicked == 9 and listUsed[-1] == 8 or intClicked == 13 and listUsed[-1] == 12 or intClicked == 13:                                break                            else:                                #Checks to see if user has won                                if intTotal == Grid4.WinningTotal - 1 and intClicked == Grid4.WinningSquare:                                    #Auto next level                                    intTotal = 0                                    if intLevel != 3:                                        LevelUp()                                    else:                                        LevelUp()                                        break                                    #CHANGE THESE TO THE ACTUAL VALUES THAT I WILL USE                                    if intLevel == 1:                                        GenerateBoard()                                        FourByFour()                                        break                                    else:                                        GenerateBoard()                                        FourByFour()                                        break                                #Working out the users score                                if intClicked == listUsed[-1]:                                    intTotal -= Grid4.list[intClicked - 1]                                else:                                    intTotal += Grid4.list[intClicked - 1]                                GenerateTile(xLeft, yUp, xRight, yDown, intClicked)                                #Adding the total                                GenerateGrid()                                #Breaks the loop after the definition is triggered                                break                        else:                            break                    else:                        xLeft += 100                        xRight += 100                yUp += 75                yDown += 75    except:        pass#Running importsimport osfrom tkinter import *from tkinter import ttkimport tkinterimport randomimport sysfrom time import time, sleep#Sets up Music for Windows/Macglobal intPlayed, intGameMode, intInGame, label_image, intName, intMusic, intRecreate, intRecreate1, intRecreate2, intRecreate3, intLeaveintMusic = 0root = tkinter.Tk()root.title("Operational")root.resizable(False, False)#Checks the users OS.#If OS is windows winsound is imported#NOTE windows os.name == "nt"if os.name == 'nt':    import winsound#If Mac or Other winsound is skipped because winsound is for windows onlyelse:    popup = Tk()    popup.wm_title("System")    label = ttk.Label(popup, text = "Music playback functionality is \n only availible on windows OS", font="DocChampa 12")    label.pack(side="top", fill="x", pady=10)    B1 = ttk.Button(popup, text="Okay", command = popup.destroy)    B1.pack()    intMusic = 1class Grids:    def __init__(self, list, WinningTotal, WinningSquare):        self.list = list        self.WinningTotal = WinningTotal        self.WinningSquare = WinningSquare    def SetValues(self, list, WinningTotal, WinningSquare):         self.list = list        self.WinningTotal = WinningTotal        self.WinningSquare = WinningSquare#Sets the grid layouts upGrid1 = Grids([0], 0, 0)Grid4 = Grids([0], 0, 0)#This is what starts the programintPlayed = 0intName = 0label_image = PhotoImage(file="MegaPhone White.gif")intInGame = 0intLevel = 0intRecreate = 0intRecreate1 = 0intRecreate2 = 0intRecreate3 = 0intLeave = 0intNameEntered = 0#Sets up the game modesintGameMode = 0canvas = Canvas(root, width=600, height=600, bg = 'white')canvas.create_text(300,100, fill="black",font="Times 40 bold", text="Operational")canvas.pack()GenerateHome()